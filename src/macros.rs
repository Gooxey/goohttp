//! This module exports the [`router`](crate::router) macro used to simplify the route setup of [`axum Routers`](axum::Router)

/// # Do not use this macro!
/// # Use the [`router`] macro instead.
#[doc(hidden)]
#[macro_export]
macro_rules! __router_internally {
    // Used for actual routes
    {
        $router:ident;
        $route:ident,
        $request_type:ident
        $(
            ,
            $parameter:literal
        ) *
    } => {
        $router.route(
            & {
                let mut route;
                if std::stringify!($route) == "index" {
                    route = "/".to_string();
                } else if std::stringify!($route) == "remaining" {
                    route = "/*remaining".to_string();
                } else {
                    route = format!("/{}", std::stringify!($route));
                }

                $ (
                    route.push_str(&format!("/{}", $parameter));
                ) ?

                route
            },
            $request_type($route::$route)
        )
    };
    // Used for route groups
    {
        $router:ident;
        $group:ident
    } => {
        $router.nest(
            & {
                let route;
                if std::stringify!($group) == "remaining" {
                    route = "/*remaining".to_string();
                } else {
                    route = format!("/{}", std::stringify!($group));
                }
                route
            },
            $group::$group()
        )
    };
}

/// An easier way to create an [`axum router`](axum::Router).
///
/// # Usage
///
/// For this example, we will look at a simple frontend setup with the following file structure:
/// ```text
/// src
/// ├── frontend
/// │   ├── api
/// │   │   ├── mod.rs
/// │   │   ├── say_hello_caller_sender.rs
/// │   │   └── say_hello.rs
/// │   ├── index.rs
/// │   ├── mod.rs
/// │   └── remaining.rs
/// └── main.rs
/// ```
///
/// We start at our entry point for the application: \
/// `src/main.rs`
/// ```
/// use frontend::serve_frontend;
///
/// mod frontend;
///
/// fn main() {
///     let frontend_router = serve_frontend(); // this function got generated by this macro
///
///     // ... code using the frontend_router
/// }
/// ```
///
/// Next, we define our root router: \
/// `src/frontend/mod.rs`
/// ```
/// use goohttp::router;
///
/// // First we define the route `/` which will be accessible via the `get` method
/// // Next, we define the `/:remaining` route, which will accept all remaining http get requests.
/// // And then link to another router group at `/api`
/// router! {
///     serve_frontend { // the name of this router
///         index, get;
///         remaining, get;
///         api
///     }
/// }
/// ```
///
/// Leaving the above code as it is will result in a compiler error because the modules and their associated functions index and api could not be found. So we need to create
/// these modules as well. \
/// First, we define our route index: \
/// `src/frontend/index.rs`
/// ```
/// use goohttp::axum::response::IntoResponse;
///
/// pub async fn index() -> impl IntoResponse {
///     "Hello World!".into_response()
/// }
/// ```
///
/// Then, we define our remaining routes (everything except for the routes `/` and `/api` routes): \
/// `src/frontend/remaining.rs`
/// ```
/// use goohttp::axum::{
///     extract::Path,
///     response::IntoResponse
/// };
///
/// pub async fn remaining(Path(remaining): Path<String>) -> impl IntoResponse {
///     format!("called remaining with the route `{remaining}`").into_response()
/// }
/// ```
///
/// Now all we need to do is define our router group at `/api`: \
/// `src/frontend/api/mod.rs`
/// ```
/// use goohttp::router;
///
/// // Our api will have two routes both taking some arguments, as indicated by the additional
/// // strings starting with a column.
/// // Since this macro is using the axum router internally, their rules apply, when defining
/// // arguments to routes.
/// router! {
///     api {
///         // This will, when combined with the root router, result in the route
///         // `/api/say_hello/{any argument here}`
///         say_hello, get, ":caller";
///         // And this in the route
///         // `/api/say_hello_caller_sender/{any argument here}/{any argument here}`
///         say_hello_caller_sender, get, ":caller", ":sender"
///     }
/// }
/// ```
///
/// All that remains is to define the two remaining routes: \
/// `src/frontend/api/say_hello.rs`
/// ```
/// use goohttp::axum::{
///     extract::Path,
///     response::IntoResponse,
/// };
///
/// pub async fn say_hello(Path(caller): Path<String>) -> impl IntoResponse {
///     format!("said hello from {caller}").into_response()
/// }
/// ```
///
/// `src/frontend/api/say_hello_caller_sender.rs`
/// ```
/// use goohttp::axum::{
///     extract::Path,
///     response::IntoResponse,
/// };
///
/// pub async fn say_hello_caller_sender(
///     Path((caller, sender)): Path<(String, String)>
/// ) -> impl IntoResponse {
///     format!("said hello from {caller} to {sender}").into_response()
/// }
/// ```
///
/// As a result, we will have the following routes defined for our `frontend_router`:
/// - `/`
/// - `/{any argument here}`
/// - `/api/say_hello/{any argument here}`
/// - `/api/say_hello_caller_sender/{any argument here}/{any argument here}`
///
/// For more details on how routes work, see [axum's description](https://docs.rs/axum/latest/axum/routing/struct.Router.html#method.route).
#[macro_export]
macro_rules! router {
    {
        $group_id:ident {
            $ (
                $route:ident
                $ (
                    ,
                    $request_type:ident
                    $(
                        ,
                        $parameter:literal
                    ) *
                ) ?
            ); *
            $( ; )?
        }
    } => {
        use $crate::axum::{
            Router,
            routing::*
        };
        $ (
            mod $route;
        ) *

        pub fn $group_id() -> Router {
            let mut router = Router::new();
            $ (
                // Dynamically generate either an actual route or a group of routes using the hidden patterns of this macro.
                router = $crate::__router_internally! {
                    router;
                    $route
                    $ (
                        ,
                        $request_type
                        $ (
                            ,
                            $parameter
                        ) *
                    ) ?
                };
            ) *
            router
        }
    };
}
